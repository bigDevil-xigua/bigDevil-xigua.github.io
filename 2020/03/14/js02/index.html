<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="学习前端知识"><title>js-原型与原型链和构造函数 | 西瓜田</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">js-原型与原型链和构造函数</h1><a id="logo" href="/.">西瓜田</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">js-原型与原型链和构造函数</h1><div class="post-meta">Mar 14, 2020</div><div class="post-content"><h2 id="原型，原型链，构造函数"><a href="#原型，原型链，构造函数" class="headerlink" title="原型，原型链，构造函数"></a>原型，原型链，构造函数</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><pre><code>函数（简单的说就是重复执行的代码块；只定义一次，但可能被执行或调用任意次）
构造函数（通过  new 函数名    来实例化对象的函数叫构造函数）</code></pre><ul>
<li><p>任何的函数都可以作为构造函数存在。之所以有构造函数与普通函数之分，主要从功能上进行区别的.构造函数的主要功  能为。</p>
</li>
<li><p>创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写。另外就是调用方式的不同，普通函数是直接调用，而构造函数需要使用new关键字来调用。</p>
</li>
<li><p>new申请内存, 创建对象,当调用new时，后台会隐式执行new Object()创建对象。所以，通过new创建的字符串、数字是引用类型，而是非值类型。</p>
<h4 id="new操作符具体做了什么"><a href="#new操作符具体做了什么" class="headerlink" title="new操作符具体做了什么"></a>new操作符具体做了什么</h4></li>
<li><p>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</p>
</li>
<li><p>2、属性和方法被加入到 this 引用的对象中。</p>
</li>
<li><p>3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>与大部分面向对象(OOP)语言不同，ES6之前并没有引入类（class）的概念，JavaScript并非通过类而是直接通过构造函数来创建实例。每创建一个实例，就会创建一遍属性和方法，为什么不把方法和属性单独放到一个地方，并让所有的实例都可以访问到呢?这就需要原型(prototype)</p>
</li>
<li><p>原型是一个对象，其他对象可以通过它实现属性继承</p>
</li>
<li><p>在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个prototype属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中</p>
</li>
<li><p>prototype是函数才有的属性</p>
</li>
<li><p>_proto_是每个对象都有的属性  </p>
</li>
<li><p>JavaScript 的对象中都包含了一个[[Prototype]]内部属性，这个属性所对应的就是该对象的原型。[[Prototype]]作为对象的内部属性，是不能被直接访问的。所以为了方便查看一个对象的原型，某些浏览器中提供了<strong>proto</strong>这个非标准（不是所有浏览器都支持）的访问器（ECMA 引入了标准对象原型访问器Object.getPrototype(object)）。</p>
</li>
<li><p>_proto_的指向取决于对象创建时的实现方式<br> . var a ={}(子面量方式 var a = new Object()) a._proto_指向 function Object 的prototype<br> . var A = function(){}<br>   var a = new A()<br>   a._proto_指向 function A的prototype<br> . var a ={} var b = Object.create(a) b._proto_指向 a (使用现有的对象来提供新创建的对象的proto)</p>
</li>
<li><p>new Object() 通过构造函数来创建对象, 添加的属性是在自身实例下。<br> Object.create() es6创建对象的另一种方式，可以理解为继承一个对象, 添加的属性是在原型下</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3></li>
<li><p>在JavaScript中万物都是对象，对象和对象之间也有关系，并不是孤立存在的</p>
</li>
<li><p>因为每个对象和原型都有原型，对象的原型指向对象的父，而父的原型又指向父的父,最终指向null，这种原型层层连接起来的就构成了原型链<br> var A = function(){}<br> var a = new A();<br> a.<em>proto</em> 指向 A.prototype<br> A.prototype.<em>proto</em> 指向 Object.prototype<br>Object.prototype._proto_指向null</p>
</li>
<li><p>当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined。  </p>
</li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2020/03/14/js03/">js-this的理解</a><a class="next" href="/2020/03/13/js01/">创建自己的blog</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://bigdevil-xigua-91.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/js09/">js-变量提升</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/18/js07/">js-类与对象的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/18/js08/">js-闭包</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/17/js06/">js-call apply bind</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/16/js05/">js-同步异步和微任务宏任务</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/js04/">js-深拷贝与浅拷贝和赋值</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/14/js03/">js-this的理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/14/js02/">js-原型与原型链和构造函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/13/js01/">创建自己的blog</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://baifannn.gitee.io/blog/" title="免费赠送" target="_blank">免费赠送</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">西瓜田.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>