<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="学习前端知识"><title>js-闭包 | 西瓜田</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">js-闭包</h1><a id="logo" href="/.">西瓜田</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">js-闭包</h1><div class="post-meta">Mar 18, 2020</div><div class="post-content"><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>   闭包就是能够读取其他函数内部变量的函数</p>
<ul>
<li>变量的作用域 全局变量和局部变量<br>1）函数内部可以直接读取全局变量<br>2）正常情况下在函数外部自然无法读取函数内的局部变量<br>3）函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量</li>
<li>在一些特殊情况下，我们需要需要得到函数内的局部变量，在函数的内部，再定义一个函数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  n=<span class="number">111</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(n); <span class="comment">//111</span></span><br><span class="line">　　　　&#125;</span><br><span class="line">   <span class="keyword">return</span> f2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> result=f1();</span><br><span class="line">  result();</span><br><span class="line">  f2可以读取f1中的局部变量，那么只要把f2作为返回值，就可以在f1外部读取它的内部变量</span><br><span class="line">  f2函数，就是闭包</span><br><span class="line">  闭包就是将函数内部和函数外部连接起来的一座桥梁</span><br></pre></td></tr></table></figure></li>
<li>闭包的作用,有点<br>可以读取函数内部的变量<br>让这些变量的值始终保持在内存中<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">var</span> n=<span class="number">111</span>;</span><br><span class="line">　　　　  nAdd=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;n+=<span class="number">1</span>&#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">　　　　 &#125;</span><br><span class="line"> <span class="keyword">return</span> f2;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> result=f1();</span><br><span class="line"> result(); <span class="comment">//111</span></span><br><span class="line"> nAdd();</span><br><span class="line"> result(); <span class="comment">// 112</span></span><br><span class="line"> result实际上就是闭包f2函数</span><br><span class="line"> 一共运行了两次</span><br><span class="line"> 这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除</span><br><span class="line"> 原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，</span><br><span class="line"> 因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收</span><br><span class="line"> nAdd=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;n+=<span class="number">1</span>&#125;”这一行，首先在nAdd前面没有使用<span class="keyword">var</span>关键字，因此 nAdd是一个全局变量，而不是局部变量。</span><br><span class="line"> 其次，nAdd的值是一个匿名函数（anonymous <span class="function"><span class="keyword">function</span>），而这个匿名函数本身也是一个闭包，所以<span class="title">nAdd</span>相当于是一个<span class="title">setter</span>，</span></span><br><span class="line"><span class="function"> 可以在函数外部对函数内部的局部变量进行操作</span></span><br></pre></td></tr></table></figure>
<ul>
<li>闭包的缺点<br>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，<br>否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，<br>将不使用的局部变量全部删除<br>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，<br>把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），<br>这时一定要小心，不要随便改变父函数内部变量的值</li>
<li>例1<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> result = [];</span><br><span class="line"> <span class="keyword">for</span> （<span class="keyword">var</span> i = <span class="number">0</span>； i&lt;<span class="number">10</span>; i++）&#123;</span><br><span class="line">   result.[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.info(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result；</span><br><span class="line">每个闭包函数访问变量i是outer执行环境下的变量i，随着循环的结束，i已经变成<span class="number">10</span>了，所以执行每个闭包函数，结果打印<span class="number">10</span>， <span class="number">10</span>， ..., <span class="number">10</span></span><br></pre></td></tr></table></figure></li>
<li>例2<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> result = [];</span><br><span class="line"> <span class="keyword">for</span> （<span class="keyword">var</span> i = <span class="number">0</span>； i&lt;<span class="number">10</span>; i++）&#123;</span><br><span class="line">   result.[i] = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">             <span class="built_in">console</span>.info(num);   都不一样</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;(i)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line"><span class="comment">// 此时访问的num，是上层函数执行环境的num，数组有10个函数对象，每个对象的执行环境下的number</span></span><br></pre></td></tr></table></figure></li>
<li>例3<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line"> name: <span class="string">''</span>object<span class="string">"，</span></span><br><span class="line"><span class="string"> getName： function() &#123;</span></span><br><span class="line"><span class="string"> return function() &#123;</span></span><br><span class="line"><span class="string">      console.info(this.name)</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string"> object.getName()()    // underfined</span></span><br><span class="line"><span class="string"> // 因为里面的闭包函数是在window作用域下执行的，也就是说，this指向windows</span></span><br></pre></td></tr></table></figure></li>
<li>例4<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span>  <span class="title">showId</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>)</span><br><span class="line"> el.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> aler(el.id)   <span class="comment">// 这样会导致闭包引用外层的el，当执行完showId后，el无法释放</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改成下面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">showId</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">"app"</span>)</span><br><span class="line">  <span class="keyword">var</span> id  = el.id</span><br><span class="line">  el.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    aler(id)   <span class="comment">// 这样会导致闭包引用外层的el，当执行完showId后，el无法释放</span></span><br><span class="line">  &#125;</span><br><span class="line">  el = <span class="literal">null</span>    <span class="comment">// 主动释放el</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>例5 用闭包模仿块级作用域<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.info(i)</span><br><span class="line"> &#125;</span><br><span class="line"> alert(i)  <span class="comment">// 变量提升，弹出10</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//为了避免i的提升可以这样做</span></span><br><span class="line"> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">      <span class="built_in">console</span>.info(i)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"> alert(i)   <span class="comment">// underfined   因为i随着闭包函数的退出，执行环境销毁，变量回收</span></span><br></pre></td></tr></table></figure>









</li>
</ul>
</li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2020/03/18/js07/">js-类与对象的区别</a><a class="next" href="/2020/03/17/js06/">js-call apply bind</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://bigdevil-xigua-91.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/03/20/js09/">js-变量提升</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/18/js07/">js-类与对象的区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/18/js08/">js-闭包</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/17/js06/">js-call apply bind</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/16/js05/">js-同步异步和微任务宏任务</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/15/js04/">js-深拷贝与浅拷贝和赋值</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/14/js03/">js-this的理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/14/js02/">js-原型与原型链和构造函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/13/js01/">创建自己的blog</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="http://baifannn.gitee.io/blog/" title="免费赠送" target="_blank">免费赠送</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">西瓜田.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>